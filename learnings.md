- auto type for automatic type deduction
- references are helpful in for (each) loops so act like normal rather than the element being copied to a new variable 
- emplace_back() is like push_back() but can pass parameters directly to the constructor e.g. neurons.emplace_back(0, "hi", 4) is the same as neurons.push_back(Neuron(0, "hi", 4)) if neurons has type std::vector<Neuron> but avoids creating a temporary object
- cant use cout directly on a vector (duh), iterate through and do manually or overload the << operator
- when overloading a binary operator, if the overloading is defined in the class on which the overloading is to be performed, the first item is implicitly passed into the method, so only the other item needs to be specified as a parameter.
- do not need to dereference a function to call it. e.g. double func* function; func("hi") is fine. explicit dereferencing can be done (*func)("hello") but not necessary
- types are inferred in some circumstances i.e. vector<vector<int>> container; container.push_back({{8}, {4}}) is fine - no need to specify the type (although you can)
- relu training requires much lower learning rate for reliable training with SGD
- relu does not like NAG (parameter space not smooth enough?), but likes Adam.
- you can unpack a struct into multiple variables with auto [a, b] = my_struct;
- shuffling training data is very important for efficient training
- order of conditions in if statements is important e.g. if (!layers.empty() && dynamic_cast<DenseLayer*>(layers.back().get())) is a valid solution to the undefined behaviour of layers.back() when layers is empty.
- while base-type pointers and derived-type pointers can point to the same object, they are not the same type and should not be used interchangeably. e.g. if (dynamic_cast<DerivedType*>(base_pointer)) is not the same as if (dynamic_cast<BaseType*>(derived_pointer))
- dynamic_cast can be used to check if a pointer is of a certain type and safely return a null pointer if it is not. e.g. ConvolutionLayer* conv_layer = dynamic_cast<ConvolutionLayer*>(layer); if (!conv_layer) { throw std::runtime_error("Layer is not a convolution layer"); }
- the -> syntax is used to access members of a pointer to an object. e.g. layer->forward(input) is the same as (*layer).forward(input)
- std::vector has a range constructor i.e. std::vector<int> slice(data.begin(), data.begin() + 5); fills slice wiht the first 5 elements of data.
- references and pointers both store memory addresses, but the compiler treats them differently. References auto dereference, pointers do not. References are treated more like aliases, e.g. if you do &ref then this will return the address of the data the ref points to rather than where the reference itself is stored - unlike pointers. 
- & has two distinct uses. When in definitions/declarations it defines a variable as a reference, while when in expressions it gets the memory address of the item it acts on.
    -  e.g. for (float &element : tensor.data) {
            file.read(reinterpret_cast<char *>(&element), sizeof(float));
        }
    - the first & specifies that element should be a reference to the actual data in the tensor.data vector.
    - the second & gets the address of this reference which (as references act as aliases) gives the address of the referenced data
